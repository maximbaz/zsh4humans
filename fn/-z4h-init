# When a command is running, display it in the terminal title.
function -z4h-set-term-title-preexec() {
  emulate -L zsh
  local _z4h_fmt
  if [[ -n $SSH_CONNECTON || $P9K_SSH == 1 ]]; then
    zstyle -s :z4h:term-title:ssh   preexec _z4h_fmt || _z4h_fmt='%n@%m: ${1//\%/%%}'
  else
    zstyle -s :z4h:term-title:local preexec _z4h_fmt || _z4h_fmt='${1//\%/%%}'
  fi
  [[ -z $_z4h_fmt ]] || -z4h-set-term-title $_z4h_fmt "$@"
}

# When no command is running, display the current directory in the terminal title.
function -z4h-set-term-title-precmd() {
  emulate -L zsh
  local _z4h_fmt
  if [[ -n $SSH_CONNECTON || $P9K_SSH == 1 ]]; then
    zstyle -s :z4h:term-title:ssh   precmd _z4h_fmt || _z4h_fmt='%n@%m: %~'
  else
    zstyle -s :z4h:term-title:local precmd _z4h_fmt || _z4h_fmt='%~'
  fi
  [[ -z $_z4h_fmt ]] || -z4h-set-term-title $_z4h_fmt
}

autoload -Uz add-zsh-hook                           || return
add-zsh-hook -- preexec -z4h-set-term-title-preexec || return
add-zsh-hook -- precmd -z4h-set-term-title-precmd   || return

local pkg
typeset -gA _z4h_use
for pkg in fzf fzf-tab powerlevel10k systemd \
           zsh-completions zsh-autosuggestions zsh-syntax-highlighting; do
  zstyle -t :z4h:$pkg channel none || _z4h_use[$pkg]=1
done
typeset -grA _z4h_use

local p10k_cfg=
# If the current locale isn't UTF-8, change it to an UTF-8 one.
# Try in order: C.UTF-8, en_US.UTF-8, the first UTF-8 locale in lexicographical order.
() {
  [[ $langinfo[CODESET] == (utf|UTF)(-|)8 ]] && return 0
  (( $+commands[locale] )) || return
  local loc=(${(@M)$(locale -a):#*.(utf|UTF)(-|)8})
  (( $#loc )) || return
  export LC_ALL=${loc[(r)(#i)C.UTF(-|)8]:-${loc[(r)(#i)en_US.UTF(-|)8]:-$loc[1]}}
} && [[ $TERM != (dumb|linux) ]] || p10k_cfg+=-ascii
(( terminfo[colors] >= 256 )) || p10k_cfg+=-8color

if (( _z4h_use[powerlevel10k] )); then
  : ${POWERLEVEL9K_CONFIG_FILE:=$ZDOTDIR/.p10k${p10k_cfg}.zsh}
fi

# Enable command_not_found_handler if possible.
if (( $+functions[command_not_found_handler] )); then
  # already installed
elif [[ -x /usr/lib/command-not-found ]]; then
  -z4h-gnu-command-not-found
elif [[ -e /etc/zsh_command_not_found ]]; then
  builtin source /etc/zsh_command_not_found
elif [[ -e /usr/share/doc/pkgfile/command-not-found.zsh ]]; then
  builtin source /usr/share/doc/pkgfile/command-not-found.zsh
elif [[ -x /usr/libexec/pk-command-not-found && -S /var/run/dbus/system_bus_socket ]]; then
  command_not_found_handler() { /usr/libexec/pk-command-not-found "$@" }
elif [[ -x /data/data/com.termux/files/usr/libexec/termux/command-not-found ]]; then
  command_not_found_handler() { /data/data/com.termux/files/usr/libexec/termux/command-not-found "$@" }
elif [[ -x /run/current-system/sw/bin/command-not-found ]]; then
  command_not_found_handler() { /run/current-system/sw/bin/command-not-found "$@" }
elif (( $+commands[brew] )); then
  -z4h-brew-command-not-found
fi

if [[ $ZSH_PATCHLEVEL == zsh-5.8-0-g77d203f && $_z4h_exe == */bin/zsh &&
      -e ${_z4h_exe:h:h}/share/zsh/5.8/scripts/relocate ]]; then
  if [[ $#terminfo != 0 && -e ${_z4h_exe:h:h}/share/terminfo/$TERM[1]/$TERM ]]; then
    export TERMINFO=${_z4h_exe:h:h}/share/terminfo
  fi
  if [[ -e ${_z4h_exe:h:h}/share/man ]]; then
    manpath=(${_z4h_exe:h:h}/share/man $manpath '')
  fi
fi

function z4h-up-local-history() {
  -z4h-with-local-history 1 up-line-or-beginning-search "$@"
}
function z4h-down-local-history() {
  -z4h-with-local-history 1 down-line-or-beginning-search "$@"
}
function z4h-up-global-history() {
  -z4h-with-local-history 0 up-line-or-beginning-search "$@"
}
function z4h-down-global-history() {
  -z4h-with-local-history 0 down-line-or-beginning-search "$@"
}

function z4h-kill-word()           { -z4h-move-and-kill z4h-forward-word   }
function z4h-backward-kill-word()  { -z4h-move-and-kill z4h-backward-word  }
function z4h-kill-zword()          { -z4h-move-and-kill z4h-forward-zword  }
function z4h-backward-kill-zword() { -z4h-move-and-kill z4h-backward-zword }

function z4h-beginning-of-buffer() { CURSOR=0 }
function z4h-end-of-buffer() {
  if [[ $KEYMAP == vicmd && -n $BUFFER ]]; then
    CURSOR=$((${#BUFFER} - 1))
  else
    CURSOR=${#BUFFER}
  fi
}
function z4h-expand() { zle _expand_alias || zle .expand-word || true }

function z4h-cd-back() { -z4h-cd-rotate +1 }
function z4h-cd-forward() { -z4h-cd-rotate -0 }
function z4h-cd-up() { cd .. && -z4h-redraw-prompt }

function z4h-do-nothing() {}

autoload -Uz up-line-or-beginning-search down-line-or-beginning-search || return
autoload -Uz run-help ${^fpath}/run-help-*(N:t)                        || return
(( $+aliases[run-help] )) && unalias run-help  # make run-help more useful

if (( $+terminfo[civis] && $+terminfo[cnorm] )) && [[ -w $TTY ]]; then
  function -z4h-cursor-hide() { [[ -t 1 ]] && echoti civis || echoti civis >"$TTY" }
  function -z4h-cursor-show() { [[ -t 1 ]] && echoti cnorm || echoti cnorm >"$TTY" }
else
  function -z4h-cursor-hide() {}
  function -z4h-cursor-show() {}
fi

zle -N up-line-or-beginning-search
zle -N down-line-or-beginning-search
zle -N z4h-expand
zle -N z4h-forward-word
zle -N z4h-kill-word
zle -N z4h-backward-word
zle -N z4h-backward-kill-word
zle -N z4h-forward-zword
zle -N z4h-kill-zword
zle -N z4h-backward-zword
zle -N z4h-backward-kill-zword
zle -N z4h-beginning-of-buffer
zle -N z4h-end-of-buffer
zle -N z4h-stash-buffer
zle -N z4h-expand-or-complete
zle -N z4h-up-local-history
zle -N z4h-down-local-history
zle -N z4h-up-global-history
zle -N z4h-down-global-history
zle -N z4h-cd-back
zle -N z4h-cd-forward
zle -N z4h-cd-up
zle -N z4h-cd-down
zle -N z4h-fzf-history
zle -N z4h-autosuggest-accept
zle -N z4h-do-nothing

PROMPT_EOL_MARK='%K{red} %k'   # mark the missing \n at the end of a comand output with a red block
READNULLCMD=less               # use `less` instead of the default `more`
WORDCHARS=''                   # only alphanums make up words in word-based zle widgets
ZLE_REMOVE_SUFFIX_CHARS=''     # don't eat space when typing '|' after a tab completion
zle_highlight=('paste:none')   # disable highlighting of text pasted into the command line

TIMEFMT='user=%U system=%S cpu=%P total=%*E'  # output format of `time` reserved word

if (( ! _z4h_custom_histfile )); then
  HISTFILE=${ZDOTDIR:-~}/.zsh_history
fi
HISTSIZE=1000000000  # infinite command history
SAVEHIST=1000000000  # infinite command history

if (( _z4h_use[fzf-tab] )); then
  local bind=(
    ctrl-h:backward-kill-word
    alt-j:clear-query
    ctrl-u:clear-query
    ctrl-k:kill-line
    alt-k:unix-line-discard
    tab:down
    btab:up
    ctrl-space:toggle
    ctrl-a:select-all)
  bindkey '^I' expand-or-complete          # fzf-tab reads it during initialization
  zstyle ':fzf-tab:*' prefix       ''      # remove 'Â·'
  zstyle ':fzf-tab:*' query-string prefix  # pre-populate fzf query with the longest common prefix
  zstyle ':fzf-tab:*' command      -z4h-fzf        \
    --ansi                                         \
    --expect='$continuous_trigger'                 \
    --color='hl:$(( $#headers == 0 ? 108 : 255 ))' \
    --nth=2,3                                      \
    --delimiter='\000'                             \
    --layout=reverse                               \
    --exact                                        \
    --no-mouse                                     \
    --tiebreak=begin                               \
    --multi                                        \
    --cycle                                        \
    --query='$query'                               \
    --bind=${(j:,:)bind}                           \
    --header-lines='$#headers'                     \
    --height='$(( 100 * ($#candidates + 2) < 60 * LINES ? $#candidates + 2 : 60 * LINES / 100 ))'
  builtin source $Z4H/fzf-tab/fzf-tab.zsh
  eval "function fzf-tab-complete() {
    ${functions[fzf-tab-complete]//zle (.reset-prompt|redisplay|-R)/}
  }"
fi

# Delete all existing keymaps and reset to the default state.
bindkey -d
bindkey -e

local keymap
for keymap in emacs viins vicmd; do
  # If NumLock is off, translate keys to make them appear the same as with NumLock on.
  bindkey -M $keymap -s '^[OM'     '^M'      # enter
  bindkey -M $keymap -s '^[Ok'     '+'
  bindkey -M $keymap -s '^[Om'     '-'
  bindkey -M $keymap -s '^[Oj'     '*'
  bindkey -M $keymap -s '^[Oo'     '/'
  bindkey -M $keymap -s '^[OX'     '='

  # If someone switches our terminal to application mode (smkx), translate keys to make
  # them appear the same as in raw mode (rmkx).
  bindkey -M $keymap -s '^[OA'     '^[[A'    # up
  bindkey -M $keymap -s '^[OB'     '^[[B'    # down
  bindkey -M $keymap -s '^[OD'     '^[[D'    # left
  bindkey -M $keymap -s '^[OC'     '^[[C'    # right
  bindkey -M $keymap -s '^[OH'     '^[[H'    # home
  bindkey -M $keymap -s '^[OF'     '^[[F'    # end

  # TTY sends different key codes. Translate them to xterm equivalents.
  # Missing: {ctrl,alt,shift}+{up,down,left,right,home,end}, {ctrl,alt}+delete.
  bindkey -M $keymap -s '^[[1~'    '^[[H'    # home
  bindkey -M $keymap -s '^[[4~'    '^[[F'    # end

  # Urxvt sends different key codes. Translate them to xterm equivalents.
  bindkey -M $keymap -s '^[[7~'    '^[[H'    # home
  bindkey -M $keymap -s '^[[8~'    '^[[F'    # end
  bindkey -M $keymap -s '^[Oa'     '^[[1;5A' # ctrl+up
  bindkey -M $keymap -s '^[Ob'     '^[[1;5B' # ctrl+down
  bindkey -M $keymap -s '^[Od'     '^[[1;5D' # ctrl+left
  bindkey -M $keymap -s '^[Oc'     '^[[1;5C' # ctrl+right
  bindkey -M $keymap -s '^[[7\^'   '^[[1;5H' # ctrl+home
  bindkey -M $keymap -s '^[[8\^'   '^[[1;5F' # ctrl+end
  bindkey -M $keymap -s '^[[3\^'   '^[[3;5~' # ctrl+delete
  bindkey -M $keymap -s '^[^[[A'   '^[[1;3A' # alt+up
  bindkey -M $keymap -s '^[^[[B'   '^[[1;3B' # alt+down
  bindkey -M $keymap -s '^[^[[D'   '^[[1;3D' # alt+left
  bindkey -M $keymap -s '^[^[[C'   '^[[1;3C' # alt+right
  bindkey -M $keymap -s '^[^[[7~'  '^[[1;3H' # alt+home
  bindkey -M $keymap -s '^[^[[8~'  '^[[1;3F' # alt+end
  bindkey -M $keymap -s '^[^[[3~'  '^[[3;3~' # alt+delete
  bindkey -M $keymap -s '^[[a'     '^[[1;2A' # shift+up
  bindkey -M $keymap -s '^[[b'     '^[[1;2B' # shift+down
  bindkey -M $keymap -s '^[[d'     '^[[1;2D' # shift+left
  bindkey -M $keymap -s '^[[c'     '^[[1;2C' # shift+right
  bindkey -M $keymap -s '^[[7$'    '^[[1;2H' # shift+home
  bindkey -M $keymap -s '^[[8$'    '^[[1;2F' # shift+end

  # Tmux sends different key codes. Translate them to xterm equivalents.
  bindkey -M $keymap -s '^[[1~'    '^[[H'    # home
  bindkey -M $keymap -s '^[[4~'    '^[[F'    # end
  bindkey -M $keymap -s '^[^[[A'   '^[[1;3A' # alt+up
  bindkey -M $keymap -s '^[^[[B'   '^[[1;3B' # alt+down
  bindkey -M $keymap -s '^[^[[D'   '^[[1;3D' # alt+left
  bindkey -M $keymap -s '^[^[[C'   '^[[1;3C' # alt+right
  bindkey -M $keymap -s '^[^[[1~'  '^[[1;3H' # alt+home
  bindkey -M $keymap -s '^[^[[4~'  '^[[1;3F' # alt+end
  bindkey -M $keymap -s '^[^[[3~'  '^[[3;3~' # alt+delete

  # iTerm2 sends different key codes. Translate them to xterm equivalents.
  # Missing (depending on settings): ctrl+{up,down,left,right}, {ctrl,alt}+{delete,backspace}.
  bindkey -M $keymap -s '^[^[[A'   '^[[1;3A' # alt+up
  bindkey -M $keymap -s '^[^[[B'   '^[[1;3B' # alt+down
  bindkey -M $keymap -s '^[^[[D'   '^[[1;3D' # alt+left
  bindkey -M $keymap -s '^[^[[C'   '^[[1;3C' # alt+right
  bindkey -M $keymap -s '^[[1;9A'  '^[[1;3A' # alt+up
  bindkey -M $keymap -s '^[[1;9B'  '^[[1;3B' # alt+down
  bindkey -M $keymap -s '^[[1;9D'  '^[[1;3D' # alt+left
  bindkey -M $keymap -s '^[[1;9C'  '^[[1;3C' # alt+right
  bindkey -M $keymap -s '^[[1;9H'  '^[[1;3H' # alt+home
  bindkey -M $keymap -s '^[[1;9F'  '^[[1;3F' # alt+end
done

# Move cursor one char backward.
bindkey   '^[[D'    backward-char                  # left
# Move cursor one char forward.
bindkey   '^[[C'    forward-char                   # right
# Move cursor one line up or fetch the previous command from LOCAL history.
bindkey   '^P'      z4h-up-local-history           # ctrl+p
bindkey   '^[[A'    z4h-up-local-history           # up
# Move cursor one line down or fetch the next command from LOCAL history.
bindkey   '^N'      z4h-down-local-history         # ctrl-n
bindkey   '^[[B'    z4h-down-local-history         # down
# Move cursor one line up or fetch the previous command from GLOBAL history.
bindkey   '^[[1;5A' z4h-up-global-history          # ctrl+up
# Move cursor one line down or fetch the next command from GLOBAL history.
bindkey   '^[[1;5B' z4h-down-global-history        # ctrl+down
# Move cursor to the beginning of line.
bindkey   '^[[H'    beginning-of-line              # home
# Move cursor to the end of line.
bindkey   '^[[F'    end-of-line                    # end
# Move cursor to the beginning of buffer.
bindkey   '^[[1;5H' z4h-beginning-of-buffer        # ctrl+home
bindkey   '^[[1;3H' z4h-beginning-of-buffer        # alt+home
# Move cursor to the end of buffer.
bindkey   '^[[1;5F' z4h-end-of-buffer              # ctrl+end
bindkey   '^[[1;3F' z4h-end-of-buffer              # alt+end
# Delete the character under the cursor.
bindkey   '^D'      delete-char                    # delete
bindkey   '^[[3~'   delete-char                    # delete
# Delete next word.
bindkey   '^[d'     z4h-kill-word                  # alt+d
bindkey   '^[D'     z4h-kill-word                  # alt+D
bindkey   '^[[3;5~' z4h-kill-word                  # ctrl+del
bindkey   '^[[3;3~' z4h-kill-word                  # alt+del
# Delete previous word.
bindkey   '^W'      z4h-backward-kill-word         # ctrl+w
bindkey   '^[^?'    z4h-backward-kill-word         # alt+bs
bindkey   '^[^H'    z4h-backward-kill-word         # ctrl+alt+bs

# Move cursor one zsh word forward.
bindkey   '^[[1;6C' z4h-forward-zword              # ctrl+shift+right
# Move cursor one zsh word backward.
bindkey   '^[[1;6D' z4h-backward-zword             # ctrl+shift+left
# Delete next zsh word.
bindkey   '^[[3;6~' z4h-kill-zword                 # ctrl+shift+del

# Delete line before cursor.
bindkey   '^[k'     backward-kill-line             # alt+k
bindkey   '^[K'     backward-kill-line             # alt+K
# Delete all lines.
bindkey   '^[j'     kill-buffer                    # alt+j
bindkey   '^[J'     kill-buffer                    # alt+J
# Push buffer to ephemeral history (won't be saved to HISTFILE) and delete all lines.
bindkey   '^[o'     z4h-stash-buffer               # alt+o
bindkey   '^[O'     z4h-stash-buffer               # alt+O
# Accept autosuggestion.
bindkey   '^[m'     z4h-autosuggest-accept         # alt+m
bindkey   '^[M'     z4h-autosuggest-accept         # alt+M
# Redo.
bindkey   '^[/'     redo                           # alt+/
# Expand alias/glob/parameter.
bindkey   '^ '      z4h-expand                     # ctrl+space
if (( _z4h_use[fzf-tab] )); then
  # Generic command completion.
  bindkey '^I'      z4h-expand-or-complete         # tab
fi
if (( _z4h_use[fzf] )); then
  # Command history.
  bindkey '^R'      z4h-fzf-history                # ctrl+r
fi
# Show help for the command at cursor.
bindkey   '^[h'     run-help                       # alt+h
bindkey   '^[H'     run-help                       # alt+H
# Do nothing (better than printing '~').
bindkey   '^[[5~'   z4h-do-nothing                 # pageup
bindkey   '^[[6~'   z4h-do-nothing                 # pagedown

# Move cursor one word backward.
bindkey   '^[b'     z4h-backward-word              # alt+b
bindkey   '^[B'     z4h-backward-word              # alt+B

# Move cursor one word forward.
bindkey   '^[f'     z4h-forward-word               # alt+f
bindkey   '^[F'     z4h-forward-word               # alt+F

if zstyle -t :z4h: cd-key ctrl; then
  # Move cursor one word backward.
  bindkey '^[[1;3D' z4h-backward-word              # alt+left
  # Move cursor one word forward.
  bindkey '^[[1;3C' z4h-forward-word               # alt+right
  # cd into the previous directory.
  bindkey '^[[1;5D' z4h-cd-back                    # ctrl+left
  # cd into the next directory.
  bindkey '^[[1;5C' z4h-cd-forward                 # ctrl+right
  # cd into the parent directory.
  bindkey '^[[1;5A' z4h-cd-up                      # ctrl+up
  if (( _z4h_use[fzf] )); then
    # cd into a subdirectory (interactive).
    bindkey '^[[1;5B' z4h-cd-down                  # ctrl+down
  fi
else
  # Move cursor one word backward.
  bindkey '^[[1;5D' z4h-backward-word              # ctrl+left
  # Move cursor one word forward.
  bindkey '^[[1;5C' z4h-forward-word               # ctrl+right
  # cd into the previous directory.
  bindkey '^[[1;3D' z4h-cd-back                    # alt+left
  # cd into the next directory.
  bindkey '^[[1;3C' z4h-cd-forward                 # alt+right
  # cd into the parent directory.
  bindkey '^[[1;3A' z4h-cd-up                      # alt+up
  if (( _z4h_use[fzf] )); then
    # cd into a subdirectory (interactive).
    bindkey '^[[1;3B' z4h-cd-down                  # alt+down
  fi
fi

# Use lesspipe if available. It allows you to use less on binary files (*.tar.gz, *.jpg, etc.).
if (( $+commands[lesspipe] || $+commands[lesspipe.sh] )); then
  export LESSOPEN="| /usr/bin/env ${(q)${commands[lesspipe]:-${commands[lesspipe.sh]}}} %s 2>/dev/null"
fi

# This affects every invocation of `less`.
#
#   -i   case-insensitive search unless search string contains uppercase letters
#   -R   color
#   -F   exit if there is less than one page of content
#   -X   keep content on screen after exit
#   -M   show more info at the bottom prompt line
#   -x4  tabs are 4 instead of 8
export LESS='-iRFXMx4'

export PAGER=less

# LS_COLORS is used by GNU ls and Zsh completions. LSCOLORS is used by BSD ls.
export LS_COLORS='fi=00:mi=00:mh=00:ln=01;36:or=01;31:di=01;34:ow=04;01;34:st=34:tw=04;34:'
LS_COLORS+='pi=01;33:so=01;33:do=01;33:bd=01;33:cd=01;33:su=01;35:sg=01;35:ca=01;35:ex=01;32'
export LSCOLORS='ExGxDxDxCxDxDxFxFxexEx'

# Configure completions.
zstyle ':completion:*'                  completer         "_complete" "_ignored"
zstyle ':completion:*'                  matcher-list      "m:{[:lower:]}={[:upper:]}" "l:|=* r:|=*"
zstyle ':completion:*'                  menu              "false"
zstyle ':completion:*'                  verbose           "true"
zstyle ':completion:::::'               insert-tab        "pending"
zstyle ':completion:*:*:-subscript-:*'  tag-order         "indexes parameters"
zstyle ':completion:*:-tilde-:*'        tag-order         "named-directories" "users"
zstyle ':completion:*'                  squeeze-slashes   "true"
zstyle ':completion:*'                  single-ignored    "show"
zstyle ':completion:*:(rm|kill|diff):*' ignore-line       "other"
zstyle ':completion:*:rm:*'             file-patterns     "*:all-files"
zstyle ':completion:*'                  use-cache         "true"
zstyle ':completion:*'                  cache-path        "$Z4H/cache/zcompcache-$ZSH_VERSION"
zstyle ':completion:*:paths'            accept-exact-dirs "true"
zstyle ':completion:*'                  single-ignored    "show"

zstyle ':completion:*:git-*:argument-rest:heads'           ignored-patterns '(FETCH_|ORIG_|*/|)HEAD'
zstyle ':completion:*:git-*:argument-rest:heads-local'     ignored-patterns '(FETCH_|ORIG_|)HEAD'
zstyle ':completion:*:git-*:argument-rest:heads-remote'    ignored-patterns '*/HEAD'
zstyle ':completion:*:git-*:argument-rest:commits'         ignored-patterns '*'
zstyle ':completion:*:git-*:argument-rest:commit-objects'  ignored-patterns '*'
zstyle ':completion:*:git-*:argument-rest:recent-branches' ignored-patterns '*'

fpath+=(
  ${^${(M)fpath:#*/$ZSH_VERSION/functions}/%$ZSH_VERSION\/functions/site-functions}(FN)
  ${HOMEBREW_PREFIX:+$HOMEBREW_PREFIX/share/zsh/site-functions}(FN)
  /usr/local/share/zsh/site-functions(FN)
  /usr/share/zsh/site-functions(FN))

# Make it possible to use completion specifications and functions written for bash.
autoload -Uz bashcompinit
bashcompinit

if (( _z4h_use[powerlevel10k] )); then
  # Initialize prompt. Type `p10k configure` or edit $POWERLEVEL9K_CONFIG_FILE to customize it.
  () {
    local XDG_CACHE_HOME=$Z4H/cache/powerlevel10k
    builtin source $Z4H/powerlevel10k/powerlevel10k.zsh-theme
  }
  z4h source -c $POWERLEVEL9K_CONFIG_FILE
  -z4h-set-term-title-precmd || return
fi

local dirs=({~/bin/,~/.local/bin/,~/.cargo/bin/,/usr/local/bin/}(/N))
path=(${dirs:|path} $path)

if (( _z4h_use[zsh-autosuggestions] )); then
  if (( terminfo[colors] >= 256 )); then
    LS_COLORS+=':no=38;5;248'
    ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=244'        # the default is hard to see
  else
    LS_COLORS+=':no=1;30'
    ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=black,bold' # the default is outside of 8-color range
  fi

  ZSH_AUTOSUGGEST_MANUAL_REBIND=1

  # Tell zsh-autosuggestions how to handle different widgets.
  typeset -g ZSH_AUTOSUGGEST_EXECUTE_WIDGETS=()
  typeset -g ZSH_AUTOSUGGEST_CLEAR_WIDGETS=(
    z4h-up-local-history
    z4h-down-local-history
    z4h-up-global-history
    z4h-down-global-history
    z4h-fzf-history
  )
  typeset -g ZSH_AUTOSUGGEST_PARTIAL_ACCEPT_WIDGETS=(
    z4h-forward-word
    z4h-forward-zword
    forward-word
    emacs-forward-word
    vi-forward-word
    vi-forward-word-end
    vi-forward-blank-word
    vi-forward-blank-word-end
    vi-find-next-char
    vi-find-next-char-skip
  )
  typeset -g ZSH_AUTOSUGGEST_ACCEPT_WIDGETS=(
    end-of-line
    vi-end-of-line
    vi-add-eol
    z4h-end-of-buffer
  )

  if zstyle -T :z4h:autosuggestions forward-char accept; then
    ZSH_AUTOSUGGEST_ACCEPT_WIDGETS+=(forward-char vi-forward-char)
  else
    ZSH_AUTOSUGGEST_PARTIAL_ACCEPT_WIDGETS+=(forward-char vi-forward-char)
  fi

  builtin source $Z4H/zsh-autosuggestions/zsh-autosuggestions.zsh
fi

if (( _z4h_use[zsh-syntax-highlighting] )); then
  if (( terminfo[colors] >= 256 )); then
    typeset -gA ZSH_HIGHLIGHT_STYLES=(comment fg=96)  # the default is hard to see
  fi
  ZSH_HIGHLIGHT_MAXLENGTH=1024                # don't colorize long command lines (slow)
  ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets)  # main syntax highlighting plus matching brackets
fi

if (( _z4h_use[zsh-syntax-highlighting] && _z4h_use[zsh-autosuggestions] )); then
  typeset -gi zsh_highlight__memo_feature=0

  local event
  for event in pre-redraw init finish; do
    if (( $+widgets[zle-line-$event] )); then
      zle -A -- zle-line-$event -z4h-orig-zle-line-$event
    fi
    zle -N -- zle-line-$event -z4h-zle-line-$event
  done

  precmd_functions=(${precmd_functions:#_zsh_autosuggest_start})

  _zsh_autosuggest_widget_execute() {
    if [[ -n $POSTDISPLAY ]]; then
      BUFFER=$BUFFER$POSTDISPLAY
      region_highlight[-1]=()
      typeset -g _z4h_autosuggest_buffer=$BUFFER
      unset _z4h_autosuggestion POSTDISPLAY
    fi
    zle .accept-line
  }

  _zsh_autosuggest_widget_clear() {
    _zsh_autosuggest_invoke_original_widget "$@"
    local -i ret=$?
    if [[ $CONTEXT == start ]]; then
      [[ -z $POSTDISPLAY ]] || region_highlight[-1]=()
      if (( ret )); then
        -z4h-autosuggest-fetch
      else
        typeset -g _z4h_autosuggest_buffer=$BUFFER
        unset _z4h_autosuggestion POSTDISPLAY
      fi
    fi
    return ret
  }

  _zsh_autosuggest_widget_accept() {
    if [[ -z $POSTDISPLAY ||
          $CURSOR -lt ${#BUFFER} && $KEYMAP != vicmd ||
          $CURSOR -lt $((${#BUFFER} - 1)) ]]; then
      _zsh_autosuggest_invoke_original_widget "$@"
      return
    fi
    BUFFER="$BUFFER$POSTDISPLAY"
    region_highlight[-1]=()
    unset _z4h_autosuggestion POSTDISPLAY
    _zsh_autosuggest_invoke_original_widget "$@"
    local -i ret=$?
    typeset -g _z4h_autosuggest_buffer="$BUFFER"
    if [[ $KEYMAP == vicmd && -n $BUFFER ]]; then
      CURSOR=$((${#BUFFER} - 1))
    else
      CURSOR=${#BUFFER}
    fi
    return ret
  }

  _zsh_autosuggest_widget_partial_accept() {
    if [[ -z $POSTDISPLAY ||
          $CURSOR -lt ${#BUFFER} && $KEYMAP != vicmd ||
          $CURSOR -lt $((${#BUFFER} - 1)) ]]; then
      _zsh_autosuggest_invoke_original_widget "$@"
      return
    fi
    local -i buf_len=${#BUFFER}
    BUFFER="$BUFFER$POSTDISPLAY"
    _zsh_autosuggest_invoke_original_widget "$@"
    local -i ret=$?
    local -i cursor=CURSOR
    [[ $KEYMAP == vicmd ]] && (( ++cursor ))
    if (( cursor > buf_len )); then
      BUFFER=${BUFFER:0:$cursor}
      POSTDISPLAY=${POSTDISPLAY:$((cursor - buf_len))}
    else
      BUFFER=${BUFFER:0:$buf_len}
    fi
    typeset -g _z4h_autosuggest_buffer=$BUFFER
    return ret
  }

  _zsh_autosuggest_widget_modify() {
    _zsh_autosuggest_invoke_original_widget "$@"
    local -i retval=$?
    [[ -z $POSTDISPLAY ]] || region_highlight[-1]=()
    -z4h-autosuggest-fetch
    return retval
  }

  _zsh_autosuggest_widget_fetch() {
    [[ -z $POSTDISPLAY ]] || region_highlight[-1]=()
    -z4h-autosuggest-fetch
  }

  _zsh_autosuggest_widget_suggest() {
    [[ -z $BUFFER || $CONTEXT != start ]] && return
    [[ -z $POSTDISPLAY ]] || region_highlight[-1]=()
    POSTDISPLAY=${1-}
    typeset -g _z4h_autosuggest_buffer="$BUFFER"
    typeset -gi _z4h_autosuggestion=1
    if [[ -n $POSTDISPLAY ]]; then
      region_highlight+=(
        "${#BUFFER} $((${#BUFFER} + ${#POSTDISPLAY})) $ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE")
    fi
  }

  _zsh_autosuggest_widget_enable() {
    (( ${+_ZSH_AUTOSUGGEST_DISABLED} )) || return 0
    unset _ZSH_AUTOSUGGEST_DISABLED
    _zsh_autosuggest_widget_fetch
  }

  _zsh_autosuggest_widget_disable() {
    (( ${+_ZSH_AUTOSUGGEST_DISABLED} )) && return
    typeset -g _ZSH_AUTOSUGGEST_DISABLED
    [[ -z $POSTDISPLAY ]] || region_highlight[-1]=()
    unset POSTDISPLAY _z4h_autosuggest_buffer _z4h_autosuggestion
  }

  _zsh_autosuggest_widget_toggle() {
    if (( ${+_ZSH_AUTOSUGGEST_DISABLED} )); then
      _zsh_autosuggest_widget_enable
    else
      _zsh_autosuggest_widget_disable
    fi
  }
fi

function -z4h-post-init() {
  eval "$_z4h_opt"

  add-zsh-hook -d -- precmd -z4h-post-init

  local -aU editors=(
    vi vim nvim emacs nano gedit code kak kate mcedit joe $EDITOR $VISUAL
    bat cat less more $PAGER)
  zstyle ':completion:*:*:('${(j:|:)editors}'):*:*' ignored-patterns '*.zwc'

  zstyle ':completion:*' list-colors "${(@s.:.)LS_COLORS}"

  # Initialize completions.
  if zstyle -t ':completion::complete:' use-cache; then
    local cache
    zstyle -s ':completion::complete:' cache-path cache
    : ${cache:=${ZDOTDIR:-~}/.zcompcache}
    if [[ ! -e $cache ]]; then
      zf_mkdir -m 0700 -p -- $cache
    fi
  fi

  (( _z4h_use[zsh-completions] )) && fpath+=($Z4H/zsh-completions/src)
  (( _z4h_use[systemd]         )) && fpath+=($Z4H/systemd/shell-completion/zsh)

  unfunction compinit compdef
  autoload -Uz compinit

  local dump
  zstyle -s ':z4h:compinit' dump-path dump
  : ${dump:=$Z4H/cache/zcompdump-$ZSH_VERSION}

  local -a stat files=(${^fpath}/^([^_]*|*~|*.zwc)(.N))
  (( ! $#files )) || zstat -A stat +mtime -- $files
  local real_sig=($ZSH_VERSION $ZSH_PATCHLEVEL $files $stat)
  real_sig='# '${(V)${(pj:\0:)real_sig}}$'\n'

  local sig
  if [[ -e $dump ]] &&
     sysread -s $#real_sig sig <$dump &&
     [[ $sig == $real_sig ]] &&
     [[ -e $dump.zwc ]] &&
     zstat -A stat +mtime -- $dump $dump.zwc &&
     (( stat[2] == stat[1] + 1 )); then
    compinit -C -d $dump
  else
    local tmp=$Z4H/tmp/zcompdump.$sysparams[pid]
    zf_rm -f -- $dump $dump.zwc $tmp $tmp.2
    compinit -C -d $tmp
    { print -rn -- $real_sig; <$tmp } >$tmp.2
    zf_rm -f -- $tmp
    zf_mv -- $tmp.2 $dump
    -z4h-compile $dump
  fi

  # Replay compdef calls.
  local args
  for args in $_z4h_compdef; do
    compdef "${(@0)args}"
  done
  unset _z4h_compdef

  local cmd
  for cmd in kubectl helm rustup cargo; do
    (( $+_comps[$cmd] || ! $+commands[$cmd] )) || compdef -- -z4h-complete-$cmd $cmd
  done

  if (( _z4h_use[zsh-syntax-highlighting] && _z4h_use[zsh-autosuggestions] )); then
    () {
      local -hA widgets=(
        zle-line-finish    user:_zsh_highlight_widget_zle-line-finish
        zle-isearch-update user:_zsh_highlight_widget_zle-isearch-update
      )
      builtin source $Z4H/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
      preexec_functions=(${preexec_functions:#_zsh_highlight_preexec_hook})
      eval '_zsh_highlight() {
        if [[ ${#BUFFER} -gt ${ZSH_HIGHLIGHT_MAXLENGTH:-${#BUFFER}} ]]; then
          region_highlight=()
          return
        fi
        local -ih PENDING=0 KEYS_QUEUED_COUNT=0
        '$functions[_zsh_highlight]'
      }'
    }
    local suggest_special=(
      $ZSH_AUTOSUGGEST_EXECUTE_WIDGETS
      $ZSH_AUTOSUGGEST_CLEAR_WIDGETS
      $ZSH_AUTOSUGGEST_PARTIAL_ACCEPT_WIDGETS
      $ZSH_AUTOSUGGEST_ACCEPT_WIDGETS)
    typeset -g ZSH_AUTOSUGGEST_IGNORE_WIDGETS=(${${(k)widgets}:|suggest_special})
    unset ZSH_AUTOSUGGEST_USE_ASYNC
    _zsh_autosuggest_start
  elif (( _z4h_use[zsh-syntax-highlighting] )); then
    builtin source $Z4H/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
  fi
}

precmd_functions=(-z4h-post-init $precmd_functions)

[[ $OSTYPE == linux-* && -r /proc/version ]] && -z4h-init-wsl

[[ -e $Z4H/z4h.zsh.zwc ]] || -z4h-compile-all
() { for 1; do -z4h-compile $1; done } $ZDOTDIR/{.zshenv,.zprofile,.zshrc,.zlogin,.zlogout}(N)

# Aliases.
if (( $+commands[dircolors] )); then  # proxy for GNU coreutils vs BSD
  # Don't define aliases for commands that point to busybox.
  [[ ${${:-diff}:c:A:t} == busybox* ]] || alias diff='diff --color=auto'
  [[ ${${:-ls}:c:A:t}   == busybox* ]] || alias ls='ls --color=auto'
else
  [[ ${${:-ls}:c:A:t}   == busybox* ]] || alias ls='ls -G'
fi
[[ ${${:-grep}:c:A:t}   == busybox* ]] || alias grep='grep --color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn}'
